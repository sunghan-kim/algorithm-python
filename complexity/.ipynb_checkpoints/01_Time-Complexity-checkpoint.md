# 1. 복잡도

## 1.1 알고리즘 복잡도 계산이 필요한 이유

- 하나의 문제를 푸는 알고리즘은 다양할 수 있다.
- 다양한 알고리즘 중 어느 알고리즘이 더 좋은 지를 분석하기 위해 복잡도를 정의하고 계산함

<br>

## 1.2 알고리즘 복잡도 계산 항목

1. **시간 복잡도**
   - 알고리즘 실행 속도
2. **공간 복잡도**
   - 알고리즘이 사용하는 메모리 사이즈

- 가장 중요한 시간 복잡도를 꼭 이해하고 계산할 수 있어야 한다.
- 공간 복잡도는 잘 물어보지 않는다.

<br>

## 1.3 시간 복잡도

### 1.3.1 알고리즘 시간 복잡도의 주요 요소

- 프로그래밍에서 시간 복잡도에서 가장 영향을 많이 미치는 요소는 **반복문**이다.
- 입력의 크기가 커지면 커질수록 반복문이 알고리즘의 수행 시간을 지배한다.

<br>

### 1.3.2 알고리즘 성능 표기법

|    표기법     |           기호            | 특징                                                         |
| :-----------: | :-----------------------: | ------------------------------------------------------------ |
| Big O 표기법  |    $O\left( N \right)$    | - 알고리즘 **최악의 실행 시간**을 표기<br />- 가장 많이, 일반적으로 사용<br />- 아무리 최악의 상황이라도, 이 정도의 성능은 보장한다는 의미 |
| 오메가 표기법 | $\Omega \left( N \right)$ | - 알고리즘 **최상의 실행 시간**을 표기                       |
|  세타 표기법  | $\Theta \left( N \right)$ | - 알고리즘 **평균 실행 시간**을 표기                         |

<br>

### 1.3.3 Big O 표기법

#### 1.3.3.1 형식

- $O \left( \text{입력} \right)$

- 입력 $N$에 따라 결정되는 시간 복잡도 함수

<br>

#### 1.3.3.2 주요 표기법

- $O \left( 1 \right)$
- $O \left( log_2 n \right)$
- $O \left( n \right)$
- $O \left( n \, log_2 n \right)$
- $O \left( n^2 \right)$
- $O \left( 2^n \right)​$
- $O \left( n! \right)$

<br>

#### 1.3.3.3 주요 표기법 대소 비교

$\quad O \left( 1 \right) < 
O \left( log_2 n \right) < 
O \left( n \right) < 
O \left( n \, log_2 n \right) < 
O \left( n^2 \right) < 
O \left( 2^n \right) < 
O \left( n! \right)$

- 입력 $n$의 크기에 따라 기하급수적으로 시간 복잡도가 높아질 수 있다.

<br>

#### 1.3.3.4 계산 방법

- 단순하게 입력 $n$에 따라 몇 번 실행이 되는 지를 계산하면 된다.
- 표현식에 가장 큰 영향을 미치는 $n$의 단위로 표기한다.

<br>

- $n$이 1 이든, 100 이든, 1000 이든, 10000 이든 상관 없이 아래와 같이 실행 방법에 따라 구분된다.

|         표기법         | 실행                                                         |
| :--------------------: | ------------------------------------------------------------ |
|  $O \left( 1 \right)$  | 무조건 2회(상수 회) 실행                                     |
|  $O \left( n \right)$  | $n$에 따라 $n$번, $n+10$번, 또는 $3n+10$번 실행              |
| $O \left( n^2 \right)$ | $n$에 따라 $n^2$번, $n^2+100$번, $100 n^2 - 100$번, $300 n^2 + 1$번 실행 |

```python
# O(1) : n에 따라 횟수가 변경되지 않음
if n > 10: # 1회 실행
    print(n) # 1회 실행
# -> 총 2회 실행
```

```python
# O(n) : n에 따라 n회 실행
variable = 1 # 1회 실행
for num in range(3):
    for index in range(n):
        print(index) # 3n회 실행
# -> 총 3n+1회 실행
```

```python
# O(n^2) : n에 따라 n^2회 실행
variable = 1 # 1회 실행
for i in range(300):
    for num in range(n):
        for index in range(n):
            print(index) # 300 x n^2회 실행
# -> 총 300n^2+1회 실행
```

<br>

#### 1.3.3.5 주요 표기법별 수행 시간 비교

![](./img/bigo.png)

<br>

#### 1.3.3.6 입력값 표기 방법

**Ex) 시간 복잡도 함수가 $2 n^2 + 3 n$인 경우**

- 가장 높은 차수 = $2 n^2$
- 상수는 실제 큰 영향이 없음
- 결국 Big O 표기법으로는 $O \left( n^2 \right)$이 된다.

