# 탐색 알고리즘 특징 비교

| 구분1  | 구분2 | 탐색 알고리즘                                   | 특징                                                         | 시간 복잡도 |
| :----: | :---: | :---------------------------------------------- | ------------------------------------------------------------ | ----------- |
|   -    | 기본  | 순차 탐색<br />(Sequential Search)              | - 리스트를 앞에서 부터 하나씩 비교해서 찾음                  | $O(n)$      |
|   -    | 기본  | 이진 탐색<br />(Binary Search)                  | - 데이터 정렬<br />- 데이터를 중간값 기준으로 2개의 서브 리스트로 분리<br />- 데이터의 중간 위치가 찾고자 하는 값과 크기 비교<br />- 중간값 위치가 더 크면 왼쪽 서브 리스트를 사용해 위 과정 반복<br />- 중간값 위치가 더 작으면 오른쪽 서브 리스트를 사용해 위 과정 반복 | $O(log n)$  |
| 그래프 | 기본  | 너비 우선 탐색<br />(Breadth First Search, BFS) | - 한 단계씩 내려가면서, 해당 노드와 같은 레벨에 있는 노드(형제 노드)들을 먼저 순회<br />- **2개의 큐(`need_visit`, `visited`)를 이용해 구현**<br />- $V$ : 노드의 수<br />- $E$ : 간선의 수 | $O(V+E)$    |
| 그래프 | 기본  | 깊이 우선 탐색<br />(Depth First Search, DFS)   | - 한 노드의 자식을 타고 끝까지 순회<br />- 다시 돌아와서 다른 형제들의 자식을 타고 내려가면서 순회<br />- **1개의 스택(`need_visit`)과 1개의 큐(`visited`)를 이용해 구현**<br />- $V$ : 노드의 수<br />- $E$ : 간선의 수 | $O(V + E)$  |

<br>

# (탐색 전략) 탐욕 알고리즘 (Greedy Algorithm)

## 특징

- 최적의 해에 가까운 값을 구하기 위해 사용됨
- 여러 경우 중 하나를 결정해야 할 때마다 **매 순간 최적이라고 생각되는 경우를 선택**하는 방식으로 진행되는 알고리즘

<br>

## 탐욕 알고리즘의 예

### 예시 1 : 동전 문제

- 가장 큰 동전 순서대로 정렬

```python
def min_coin_count(value, coin_list):
    total_coin_count = 0
    details = list()
    coin_list.sort(reverse=True)
    for coin in coin_list:
        coin_num = value // coin
        total_coin_count += coin_num
        value -= coin_num * coin
        details.append([coin, coin_num])
    return total_coin_count, details

coin_list = [500, 100, 50, 1]
min_coin_count(4720, coin_list)
```

```
(31, [[500, 9], [100, 2], [50, 0], [1, 20]])
```



<br>

### 예시 2 : 부분 배낭 문제 (Fractional Knapsack Problem)

- 무게대비 가치(가치(v) / 무게(w))가 큰 순서대로 정렬

```python
def get_max_value(data_list, capacity):
    data_list = sorted(data_list, key=lambda x: x[1] / x[0], reverse=True)
    total_value = 0
    details = list()
    
    for data in data_list:
        if capacity - data[0] >= 0:
            capacity -= data[0]
            total_value += data[1]
            details.append([data[0], data[1], 1])
        else:
            fraction = capacity / data[0]
            total_value += data[1] * fraction
            details.append([data[0], data[1], fraction])
            break
    return total_value, details

data_list = [(10, 10), (15, 12), (20, 10), (25, 8), (30, 5)]
get_max_value(data_list, 30)
```

```
(24.5, [[10, 10, 1], [15, 12, 1], [20, 10, 0.25]])
```



<br>

# 탐색 알고리즘 구현

## 순차 탐색 (Sequential Search) 구현

```python
def sequential(data_list, search_data):
    for index in range(len(data_list)):
        if data_list[index] == search_data:
            return index
    return -1
```

<br>

## 이진 탐색 (Binary Search) 구현

```python
def binary_search(data, search):
    print(data)
    if len(data) == 1 and search == data[0]:
        return True
    if len(data) == 1 and search != data[0]:
        return False
    if len(data) == 0:
        return False
    
    medium = len(data) // 2
    if search == data[medium]:
        return True
    else:
        if search > data[medium]:
            return binary_search(data[medium+1:], search)
        else:
            return binary_search(data[:medium], search)
```

<br>

## 그래프 표현

<img src="./img/graph.jpg" width="400px" />

```python
graph = dict()

graph['A'] = ['B', 'C']
graph['B'] = ['A', 'D']
graph['C'] = ['A', 'G', 'H', 'I']
graph['D'] = ['B', 'E', 'F']
graph['E'] = ['D']
graph['F'] = ['D']
graph['G'] = ['C']
graph['H'] = ['C']
graph['I'] = ['C', 'J']
graph['J'] = ['I']
```

<br>

## 너비 우선 탐색 (Breadth First Search, BFS) 구현

```python
def bfs(graph, start_node):
    need_visit, visited = list(), list()
    need_visit.append(start_node)
    while need_visit:
        node = need_visit.pop(0) # FIFO
        if node not in visited:
            visited.append(node)
            need_visit.extend(graph[node])
    return visited
```

<br>

## 깊이 우선 탐색 (Depth First Search, DFS) 구현

```python
def dfs(graph, start_node):
    need_visit, visited = list(), list()
    need_visit.append(start_node)
    whlie need_visit:
        node = need_visit.pop() # LIFO
        if node not in visited:
            visited.append(node)
            need_visit.extend(graph[node])
    return visited
```

